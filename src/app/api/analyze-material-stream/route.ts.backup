import { NextRequest } from "next/server";
import { auth } from "@/auth";
import { createClient } from "@supabase/supabase-js";
import OpenAI from "openai";
import pdfParse from "pdf-parse-fork";
import crypto from "crypto";
import { parsePDFStructure, createLightweightSummary } from "@/lib/pdf-structure-parser";

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY!,
});

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!,
  {
    auth: {
      autoRefreshToken: false,
      persistSession: false,
    },
  }
);

// Optimized model selection
const STRUCTURE_MODEL = "gpt-5-mini-2025-08-07"; // For understanding PDF structure
const INSIGHT_MODEL = "gpt-5.1-2025-11-13";      // Only for deep insights

/**
 * NEW OPTIMIZED PIPELINE
 *
 * OLD (current):
 * 1. Extract text from PDF
 * 2. Split into chunks ‚Üí GPT-5-mini (3-5 calls)
 * 3. Embedding ‚Üí Clustering
 * 4. Compress clusters ‚Üí GPT-5.1 (3-5 calls)
 * 5. Generate final slides ‚Üí GPT-5.1 (12-18 calls)
 * Total: 20-30 GPT calls, 2-3 minutes, $0.15-0.25
 *
 * NEW:
 * 1. Extract text from PDF
 * 2. Parse structure automatically (0 GPT calls, <1 second, $0)
 * 3. Create lightweight summary (70-80% token reduction)
 * 4. Single GPT-5-mini call for overall structure (1 call, 2-3 seconds, $0.001)
 * 5. GPT-5.1 for insights only (3-5 calls, 5-8 seconds, $0.02)
 * Total: 4-6 GPT calls, 10-15 seconds, $0.02-0.05
 *
 * Cost reduction: 70-85%
 * Speed improvement: 8-12x faster
 */

// Next.js 15+ doesn't use config export for body size limits
// Body size is controlled in next.config.ts instead

export async function POST(request: NextRequest) {
  const encoder = new TextEncoder();
  const stream = new TransformStream();
  const writer = stream.writable.getWriter();

  const sendEvent = async (event: string, data: any) => {
    await writer.write(encoder.encode(`event: ${event}\ndata: ${JSON.stringify(data)}\n\n`));
  };

  (async () => {
    // Initialize metrics tracking
    const metrics = {
      startTime: Date.now(),
      stages: {} as Record<string, { startTime: number; endTime?: number; duration?: number }>,
      apiCalls: [] as Array<{
        model: string;
        purpose: string;
        promptTokens: number;
        completionTokens: number;
        totalTokens: number;
        duration: number;
        cost: number;
      }>,
      totalTokens: 0,
      totalCost: 0,
      totalDuration: 0,
    };

    const startStage = (stage: string) => {
      metrics.stages[stage] = { startTime: Date.now() };
    };

    const endStage = (stage: string) => {
      if (metrics.stages[stage]) {
        metrics.stages[stage].endTime = Date.now();
        metrics.stages[stage].duration = metrics.stages[stage].endTime! - metrics.stages[stage].startTime;
      }
    };

    const trackAPICall = (
      model: string,
      purpose: string,
      usage: { prompt_tokens: number; completion_tokens: number; total_tokens: number },
      startTime: number
    ) => {
      const duration = Date.now() - startTime;

      // Calculate cost based on model pricing (as of 2025)
      let cost = 0;
      if (model.includes('gpt-5-mini')) {
        // GPT-5-mini: $0.10/1M input, $0.40/1M output
        cost = (usage.prompt_tokens / 1_000_000) * 0.10 + (usage.completion_tokens / 1_000_000) * 0.40;
      } else if (model.includes('gpt-5.1')) {
        // GPT-5.1: $2.50/1M input, $10.00/1M output
        cost = (usage.prompt_tokens / 1_000_000) * 2.50 + (usage.completion_tokens / 1_000_000) * 10.00;
      }

      const call = {
        model,
        purpose,
        promptTokens: usage.prompt_tokens,
        completionTokens: usage.completion_tokens,
        totalTokens: usage.total_tokens,
        duration,
        cost,
      };

      metrics.apiCalls.push(call);
      metrics.totalTokens += usage.total_tokens;
      metrics.totalCost += cost;

      console.log(`[METRICS] ${purpose}: ${usage.total_tokens} tokens, $${cost.toFixed(4)}, ${duration}ms`);
    };

    try {
      const session = await auth();
      if (!session?.user?.email) {
        await sendEvent("error", { error: "Unauthorized" });
        await writer.close();
        return;
      }

      const formData = await request.formData();
      const file = formData.get("file") as File;
      const type = formData.get("type") as "exam" | "work";

      if (!file) {
        await sendEvent("error", { error: "No file provided" });
        await writer.close();
        return;
      }

      // ====================
      // STEP 1: Extract PDF text
      // ====================
      startStage('extract');
      await sendEvent("progress", {
        stage: "extract",
        message: "PDF ÌÖçÏä§Ìä∏ Ï∂îÏ∂ú Ï§ë..."
      });

      const arrayBuffer = await file.arrayBuffer();
      const buffer = Buffer.from(arrayBuffer);

      // Calculate file hash for caching
      const fileHash = crypto.createHash('sha256').update(buffer).digest('hex');

      // Check if we've already analyzed this exact file
      const { data: existingMaterial } = await supabase
        .from("materials")
        .select("id")
        .eq("user_id", session.user.email)
        .eq("file_hash", fileHash)
        .single();

      if (existingMaterial) {
        await sendEvent("material_created", { id: existingMaterial.id });
        await sendEvent("progress", {
          stage: "complete",
          message: "Ïù¥Ï†Ñ Î∂ÑÏÑù Í≤∞Í≥ºÎ•º ÏÇ¨Ïö©Ìï©ÎãàÎã§"
        });
        await sendEvent("complete", { materialId: existingMaterial.id });
        await writer.close();
        return;
      }

      // Upload PDF to Supabase Storage (if it's a PDF)
      const isPDF = file.type === "application/pdf";
      let fileUrl: string | null = null;

      if (isPDF) {
        await sendEvent("progress", { stage: "upload", message: "PDF ÌååÏùº ÏóÖÎ°úÎìú Ï§ë..." });

        const sanitizedEmail = session.user.email!.replace(/[^a-zA-Z0-9]/g, '_');
        const sanitizedFileName = file.name.replace(/\s+/g, '_').replace(/[^\w.-]/g, '');
        const fileName = `${Date.now()}_${sanitizedEmail}_${sanitizedFileName}`;

        const { error: uploadError } = await supabase.storage
          .from("materials")
          .upload(fileName, buffer, { contentType: "application/pdf", upsert: false });

        if (!uploadError) {
          const { data: publicUrlData } = supabase.storage.from("materials").getPublicUrl(fileName);
          fileUrl = publicUrlData.publicUrl;
          console.log(`[STORAGE] Uploaded PDF to: ${fileUrl}`);
        } else {
          console.error("[STORAGE] Error uploading PDF:", uploadError);
        }
      }

      const pdfData = await pdfParse(buffer);
      const fullText = pdfData.text;
      endStage('extract');

      // ====================
      // STEP 2: Parse structure automatically (NO LLM)
      // ====================
      startStage('parse_structure');
      await sendEvent("progress", {
        stage: "parse_structure",
        message: "Î¨∏ÏÑú Íµ¨Ï°∞ Î∂ÑÏÑù Ï§ë..."
      });

      const structuredPDF = parsePDFStructure(fullText);
      const lightweightSummary = createLightweightSummary(structuredPDF);

      console.log(`[STRUCTURE] Parsed ${structuredPDF.sections.length} sections`);
      console.log(`[STRUCTURE] Found ${structuredPDF.formulas.length} formulas`);
      console.log(`[STRUCTURE] Found ${structuredPDF.examples.length} examples`);
      console.log(`[STRUCTURE] Token reduction: ${Math.round((1 - lightweightSummary.length / fullText.length) * 100)}%`);
      endStage('parse_structure');

      // ====================
      // STEP 3: Understanding document structure (GPT-5-mini, CHUNKED PARALLEL)
      // ====================
      startStage('understand_structure');
      await sendEvent("progress", {
        stage: "understand_structure",
        message: "Î¨∏ÏÑú Íµ¨Ï°∞ Ïù¥Ìï¥ Ï§ë (Î≥ëÎ†¨ Ï≤òÎ¶¨)..."
      });

      // Split fullText into chunks for parallel processing
      const CHUNK_SIZE = Math.ceil(fullText.length / 4); // Divide into 4 chunks
      const textChunks: string[] = [];
      for (let i = 0; i < 4; i++) {
        const start = i * CHUNK_SIZE;
        const end = Math.min((i + 1) * CHUNK_SIZE, fullText.length);
        textChunks.push(fullText.substring(start, end));
      }

      console.log(`[STRUCTURE] Split document into ${textChunks.length} chunks for parallel analysis`);

      // Create base prompt template
      const createChunkPrompt = (chunkText: string, chunkIndex: number, totalChunks: number) => {
        const basePrompt = type === "exam"
        ? `Îã§ÏùåÏùÄ ÏãúÌóò ÎåÄÎπÑ ÌïôÏäµ ÏûêÎ£åÏûÖÎãàÎã§. Ïù¥ ÏûêÎ£åÎ•º 12-18Í∞úÏùò ÌïµÏã¨ ÌÜ†ÌîΩÏúºÎ°ú ÎÇòÎàÑÏñ¥Ï£ºÏÑ∏Ïöî.

**Î¨∏ÏÑú Ï†ÑÏ≤¥ Ï£ºÏ†ú**: Ïù¥ Î¨∏ÏÑúÎäî "${structuredPDF.title || 'ÌïôÏäµ ÏûêÎ£å'}"Ïóê Í¥ÄÌïú ÎÇ¥Ïö©ÏûÖÎãàÎã§.

**Ï§ëÏöî**:
- Î™®Îì† ÌïµÏã¨ Í∞úÎÖê, Í≥µÏãù, Ï†ïÏùò, ÏòàÏãúÎäî Î∞òÎìúÏãú Ïú†ÏßÄÌïòÏÑ∏Ïöî. Ï†àÎåÄ ÏÇ≠Ï†úÌïòÏßÄ ÎßàÏÑ∏Ïöî.
- ÏàòÌïô Í≥µÏãùÏùÄ Î∞òÎìúÏãú LaTeX ÌòïÏãùÏúºÎ°ú ÏûëÏÑ±ÌïòÏÑ∏Ïöî (Ïòà: $$E = mc^2$$, $$\\frac{a}{b}$$)
- Îã®ÏàúÌûà Î¨∏Ïû•ÏùÑ Ï†ïÎ¶¨ÌïòÍ≥†, Ï§ëÎ≥µÏùÑ Ï†úÍ±∞ÌïòÎêò, ÎÇ¥Ïö©Ïùò ÍπäÏù¥ÏôÄ Íµ¨Ï≤¥ÏÑ±ÏùÄ Í∑∏ÎåÄÎ°ú Ïú†ÏßÄÌïòÏÑ∏Ïöî.
- **Í∞Å ÌÜ†ÌîΩÏùò coreContent ÏûëÏÑ± Ïãú, Î∞òÎìúÏãú Ï†ÑÏ≤¥ Î¨∏ÏÑú Ï£ºÏ†ú("${structuredPDF.title || 'ÌïôÏäµ ÏûêÎ£å'}")ÏôÄÏùò Ïó∞Í≤∞ÏùÑ Î™ÖÏãúÌïòÏÑ∏Ïöî.** Ïòà: "Î®∏Ïã†Îü¨Îãù Î∂ÑÎ•ò Î™®Îç∏ÏóêÏÑú Ï†ïÌôïÎèÑÎäî..."

ÏûêÎ£å:
${lightweightSummary}

Ï∂úÎ†• ÌòïÏãù (JSON):
{
  "topics": [
    {
      "title": "ÌÜ†ÌîΩ Ï†úÎ™©",
      "keyPoints": ["ÌïµÏã¨ Ìè¨Ïù∏Ìä∏ 1 (Íµ¨Ï≤¥Ï†ÅÏúºÎ°ú, ÏµúÏÜå 15Îã®Ïñ¥)", "ÌïµÏã¨ Ìè¨Ïù∏Ìä∏ 2 (Íµ¨Ï≤¥Ï†ÅÏúºÎ°ú, ÏµúÏÜå 15Îã®Ïñ¥)", "ÌïµÏã¨ Ìè¨Ïù∏Ìä∏ 3 (Íµ¨Ï≤¥Ï†ÅÏúºÎ°ú, ÏµúÏÜå 15Îã®Ïñ¥)"],
      "hasFormula": true/false,
      "needsExample": true/false,
      "difficulty": 1-3,
      "coreContent": "Ïù¥ ÌÜ†ÌîΩÏùò ÌïµÏã¨ Í∞úÎÖêÏùÑ 3-5Î¨∏Ïû•ÏúºÎ°ú ÏÉÅÏÑ∏ÌïòÍ≤å ÏÑ§Î™Ö. Ï†ïÏùò, ÌäπÏßï, Ïôú Ï§ëÏöîÌïúÏßÄÎ•º Ìè¨Ìï®. ÏµúÏÜå 100Îã®Ïñ¥ Ïù¥ÏÉÅ."
    }
  ]
}

Í∑úÏπô:
- 12-18Í∞ú ÌÜ†ÌîΩÏúºÎ°ú Íµ¨ÏÑ±
- Í∞Å ÌÜ†ÌîΩÏùÄ ÏãúÌóòÏóê ÎÇòÏò¨ ÎßåÌïú ÌïµÏã¨ ÎÇ¥Ïö©
- keyPointsÎäî ÏµúÏÜå 3Í∞ú Ïù¥ÏÉÅ, Í∞ÅÍ∞Å **ÏµúÏÜå 15Îã®Ïñ¥ Ïù¥ÏÉÅ**ÏúºÎ°ú Íµ¨Ï≤¥Ï†ÅÏúºÎ°ú ÏûëÏÑ±
- **coreContentÎäî ÌïÑÏàòÏù¥Î©∞, ÏµúÏÜå 100Îã®Ïñ¥ Ïù¥ÏÉÅÏùò ÏÉÅÏÑ∏Ìïú ÏÑ§Î™Ö ÏûëÏÑ±. Î∞òÎìúÏãú ÏïÑÎûò Íµ¨Ï°∞Î•º Îî∞Îùº ÏûëÏÑ±:**
  * **Ï†ïÏùò:** - 1-2Î¨∏Ïû•ÏúºÎ°ú Î™ÖÌôïÌïòÍ≤å Ï†ïÏùò
  * **ÌäπÏßï:** - 2-3Î¨∏Ïû•ÏúºÎ°ú Ï£ºÏöî ÌäπÏßï ÏÑ§Î™Ö
  * **Ï§ëÏöîÏÑ±:** - 1-2Î¨∏Ïû•ÏúºÎ°ú Ïôú Ï§ëÏöîÌïúÏßÄ ÏÑ§Î™Ö
  * (ÏÑ†ÌÉù) **ÏàòÏãù:** - ÏàòÏãùÏù¥ ÏûàÎã§Î©¥ LaTeX ÌòïÏãùÏúºÎ°ú
  * Ïòà: "Ï†ïÏùò: Î®∏Ïã†Îü¨Îãù Î∂ÑÎ•ò Î™®Îç∏ÏóêÏÑú Training setÏùÄ Î™®Îç∏Ïù¥ Ìå®ÌÑ¥ÏùÑ ÌïôÏäµÌïòÎäî Îç∞ ÏÇ¨Ïö©ÎêòÎäî Îç∞Ïù¥ÌÑ∞ÏÖãÏûÖÎãàÎã§. Ï†ÑÏ≤¥ Îç∞Ïù¥ÌÑ∞Ïùò 60-80%Î•º Ï∞®ÏßÄÌï©ÎãàÎã§. ÌäπÏßï: Î™®Îç∏Ïùò Í∞ÄÏ§ëÏπò(weight)ÏôÄ Ìé∏Ìñ•(bias)ÏùÑ Ï°∞Ï†ïÌïòÎäî Í≥ºÏ†ïÏóêÏÑú ÌïµÏã¨Ï†ÅÏù∏ Ïó≠Ìï†ÏùÑ ÌïòÎ©∞, Validation setÏùÄ ÌïòÏù¥ÌçºÌååÎùºÎØ∏ÌÑ∞ ÌäúÎãùÏóê, Test setÏùÄ ÏµúÏ¢Ö ÌèâÍ∞ÄÏóêÎßå ÏÇ¨Ïö©Îê©ÎãàÎã§. Ï§ëÏöîÏÑ±: Î®∏Ïã†Îü¨Îãù Î∂ÑÎ•ò Î™®Îç∏Ïùò ÏÑ±Îä•ÏùÑ Ï†ïÌôïÌûà ÌèâÍ∞ÄÌïòÎ†§Î©¥ Ïù¥ ÏÑ∏ Îç∞Ïù¥ÌÑ∞ÏÖãÏùÑ Î™ÖÌôïÌûà Íµ¨Î∂ÑÌï¥Ïïº ÌïòÎ©∞, Í∑∏Î†áÏßÄ ÏïäÏúºÎ©¥ Í≥ºÏ†ÅÌï©(overfitting) Î¨∏Ï†úÍ∞Ä Î∞úÏÉùÌï©ÎãàÎã§."
- Í≥µÏãù, ÏàòÏãù, Ï†ïÏùòÎäî Ï†àÎåÄ ÎàÑÎùΩÌïòÏßÄ Îßê Í≤É
- difficulty: 1=Ïâ¨ÏõÄ, 2=Î≥¥ÌÜµ, 3=Ïñ¥Î†§ÏõÄ (3Ïù¥Î©¥ Î∞òÎìúÏãú ÏòàÏãú ÌïÑÏöî)`
        : `Îã§ÏùåÏùÄ ÏóÖÎ¨¥ ÏûêÎ£åÏûÖÎãàÎã§. Ïù¥ ÏûêÎ£åÎ•º 12-18Í∞úÏùò ÌïµÏã¨ ÌÜ†ÌîΩÏúºÎ°ú ÎÇòÎàÑÏñ¥Ï£ºÏÑ∏Ïöî.

**Î¨∏ÏÑú Ï†ÑÏ≤¥ Ï£ºÏ†ú**: Ïù¥ Î¨∏ÏÑúÎäî "${structuredPDF.title || 'ÏóÖÎ¨¥ Í∞ÄÏù¥Îìú'}"Ïóê Í¥ÄÌïú ÎÇ¥Ïö©ÏûÖÎãàÎã§.

**Ï§ëÏöî**:
- Î™®Îì† ÌïµÏã¨ Í∞úÎÖê, ÌîÑÎ°úÏÑ∏Ïä§, ÏòàÏãú, Ï£ºÏùòÏÇ¨Ìï≠ÏùÄ Î∞òÎìúÏãú Ïú†ÏßÄÌïòÏÑ∏Ïöî.
- ÏàòÏãùÏù¥ÎÇò Í≥µÏãùÏù¥ ÏûàÎã§Î©¥ LaTeX ÌòïÏãùÏúºÎ°ú ÏûëÏÑ±ÌïòÏÑ∏Ïöî (Ïòà: $$ROI = \\frac{ÏàòÏùµ}{ÎπÑÏö©} \\times 100$$)
- Îã®ÏàúÌûà Î¨∏Ïû•ÏùÑ Ï†ïÎ¶¨ÌïòÍ≥†, Ï§ëÎ≥µÏùÑ Ï†úÍ±∞ÌïòÎêò, Ïã§Î¨¥Ï†Å ÎîîÌÖåÏùºÏùÄ Í∑∏ÎåÄÎ°ú Ïú†ÏßÄÌïòÏÑ∏Ïöî.
- **Í∞Å ÌÜ†ÌîΩÏùò coreContent ÏûëÏÑ± Ïãú, Î∞òÎìúÏãú Ï†ÑÏ≤¥ Î¨∏ÏÑú Ï£ºÏ†ú("${structuredPDF.title || 'ÏóÖÎ¨¥ Í∞ÄÏù¥Îìú'}")ÏôÄÏùò Ïó∞Í≤∞ÏùÑ Î™ÖÏãúÌïòÏÑ∏Ïöî.** Ïòà: "ÎîîÏßÄÌÑ∏ ÎßàÏºÄÌåÖ Ï†ÑÎûµÏóêÏÑú SEO ÏµúÏ†ÅÌôîÎäî..."

ÏûêÎ£å:
${lightweightSummary}

Ï∂úÎ†• ÌòïÏãù (JSON):
{
  "topics": [
    {
      "title": "ÌÜ†ÌîΩ Ï†úÎ™©",
      "keyPoints": ["ÌïµÏã¨ Ìè¨Ïù∏Ìä∏ 1 (Íµ¨Ï≤¥Ï†ÅÏúºÎ°ú, ÏµúÏÜå 15Îã®Ïñ¥)", "ÌïµÏã¨ Ìè¨Ïù∏Ìä∏ 2 (Íµ¨Ï≤¥Ï†ÅÏúºÎ°ú, ÏµúÏÜå 15Îã®Ïñ¥)", "ÌïµÏã¨ Ìè¨Ïù∏Ìä∏ 3 (Íµ¨Ï≤¥Ï†ÅÏúºÎ°ú, ÏµúÏÜå 15Îã®Ïñ¥)"],
      "hasFormula": false,
      "needsExample": true/false,
      "difficulty": 1-3,
      "coreContent": "Ïù¥ ÌÜ†ÌîΩÏùò ÌïµÏã¨ ÌîÑÎ°úÏÑ∏Ïä§/ÏõêÏπôÏùÑ 3-5Î¨∏Ïû•ÏúºÎ°ú ÏÉÅÏÑ∏ÌïòÍ≤å ÏÑ§Î™Ö. Î¨¥ÏóáÏùÑ, Ïñ¥ÎñªÍ≤å, Ïôú ÌïòÎäîÏßÄ Ìè¨Ìï®. ÏµúÏÜå 100Îã®Ïñ¥ Ïù¥ÏÉÅ."
    }
  ]
}

Í∑úÏπô:
- 12-18Í∞ú ÌÜ†ÌîΩÏúºÎ°ú Íµ¨ÏÑ±
- Í∞Å ÌÜ†ÌîΩÏùÄ ÏóÖÎ¨¥Ïóê ÌïÑÏàòÏ†ÅÏù∏ ÎÇ¥Ïö©
- keyPointsÎäî ÏµúÏÜå 3Í∞ú Ïù¥ÏÉÅ, Í∞ÅÍ∞Å **ÏµúÏÜå 15Îã®Ïñ¥ Ïù¥ÏÉÅ**ÏúºÎ°ú Ïã§Î¨¥Ï†ÅÏúºÎ°ú ÏûëÏÑ±
- **coreContentÎäî ÌïÑÏàòÏù¥Î©∞, ÏµúÏÜå 100Îã®Ïñ¥ Ïù¥ÏÉÅÏùò ÏÉÅÏÑ∏Ìïú ÏÑ§Î™Ö ÏûëÏÑ±. Î∞òÎìúÏãú ÏïÑÎûò Íµ¨Ï°∞Î•º Îî∞Îùº ÏûëÏÑ±:**
  * **Ï†ïÏùò:** - 1-2Î¨∏Ïû•ÏúºÎ°ú Î™©Ï†Å/Ï†ïÏùò
  * **Î∞©Î≤ï:** - 2-3Î¨∏Ïû•ÏúºÎ°ú Íµ¨Ï≤¥Ï†Å ÌîÑÎ°úÏÑ∏Ïä§/Î∞©Î≤ïÎ°†
  * **Ï§ëÏöîÏÑ±:** - 1-2Î¨∏Ïû•ÏúºÎ°ú ÎπÑÏ¶àÎãàÏä§ ÏûÑÌå©Ìä∏/Ïã§Î¨¥Ï†Å Í∞ÄÏπò
  * (ÏÑ†ÌÉù) **ÏàòÏãù:** - ÏàòÏãùÏù¥ ÏûàÎã§Î©¥ LaTeX ÌòïÏãùÏúºÎ°ú
  * Ïòà: "Ï†ïÏùò: ÎîîÏßÄÌÑ∏ ÎßàÏºÄÌåÖ Ï†ÑÎûµÏóêÏÑú Í≥†Í∞ù ÏÑ∏Í∑∏Î®ºÌä∏ Î∂ÑÏÑùÏùÄ Í≥†Í∞ùÏùÑ ÌñâÎèô Ìå®ÌÑ¥, Íµ¨Îß§Î†•, ÏÑ†Ìò∏ÎèÑÏóê Îî∞Îùº Í∑∏Î£πÏúºÎ°ú ÎÇòÎàÑÎäî ÌîÑÎ°úÏÑ∏Ïä§ÏûÖÎãàÎã§. Î∞©Î≤ï: RFM(Recency, Frequency, Monetary) Î™®Îç∏Ïù¥ÎÇò K-means ÌÅ¥Îü¨Ïä§ÌÑ∞ÎßÅÏùÑ ÏÇ¨Ïö©ÌïòÎ©∞, Í∞Å ÏÑ∏Í∑∏Î®ºÌä∏Î≥ÑÎ°ú ÎßûÏ∂§Ìòï ÎßàÏºÄÌåÖ Ï†ÑÎûµÏùÑ ÏàòÎ¶ΩÌï©ÎãàÎã§. Ïù¥Î•º ÌÜµÌï¥ ÎßàÏºÄÌåÖ ÏòàÏÇ∞ Ìö®Ïú®ÏùÑ 30-50% ÎÜíÏùº Ïàò ÏûàÏäµÎãàÎã§. Ï§ëÏöîÏÑ±: ÎîîÏßÄÌÑ∏ ÎßàÏºÄÌåÖÏùò ROIÎ•º Í∑πÎåÄÌôîÌïòÎ†§Î©¥ ÏÑ∏Í∑∏Î®ºÌä∏Î•º Ï†úÎåÄÎ°ú ÎÇòÎà†Ïïº ÌïòÎ©∞, Í∑∏Î†áÏßÄ ÏïäÏúºÎ©¥ ÌèâÍ∑†Í∞í Í∏∞Î∞òÏùò ÏûòÎ™ªÎêú ÏùòÏÇ¨Í≤∞Ï†ïÏùÑ ÌïòÍ≤å Îê©ÎãàÎã§."
- Ïã§Î¨¥ ÏòàÏãú, Ï£ºÏùòÏÇ¨Ìï≠ÏùÄ Ï†àÎåÄ ÎàÑÎùΩÌïòÏßÄ Îßê Í≤É
- difficulty: 1=Í∏∞Î≥∏, 2=Ï§ëÍ∏â, 3=Í≥†Í∏â (3Ïù¥Î©¥ Î∞òÎìúÏãú ÏòàÏãú ÌïÑÏöî)`;

      const structureCallStart = Date.now();
      const structureResponse = await openai.chat.completions.create({
        model: STRUCTURE_MODEL,
        messages: [
          {
            role: "system",
            content: "You are a document structure analyzer. Output only valid JSON."
          },
          { role: "user", content: structurePrompt }
        ],
        response_format: { type: "json_object" },
        temperature: 1.0,
      });

      // Track Mini API call
      if (structureResponse.usage) {
        trackAPICall(
          STRUCTURE_MODEL,
          "Document Structure Analysis (Mini)",
          structureResponse.usage,
          structureCallStart
        );
      }

      const structure = JSON.parse(structureResponse.choices[0].message.content!);
      const topics = structure.topics;

      console.log(`[STRUCTURE] Identified ${topics.length} topics`);
      endStage('understand_structure');

      // ====================
      // STEP 4: Create material in database
      // ====================
      const { data: material, error: materialError } = await supabase
        .from("materials")
        .insert({
          user_id: session.user.email,
          title: file.name.replace(/\.[^/.]+$/, ""),
          content: fullText.substring(0, 50000),
          type,
          analysis: { topics: topics.length, status: 'processing' },
          file_hash: fileHash,
          file_url: fileUrl,
        })
        .select()
        .single();

      if (materialError || !material) {
        console.error("[MATERIAL] Error creating material:", materialError);
        throw new Error(`Failed to create material: ${materialError?.message || 'Unknown error'}`);
      }

      await sendEvent("material_created", { id: material.id });

      // ====================
      // STEP 5: Generate slides (parallel, with template + GPT-5.1 for insights)
      // ====================
      startStage('generating_pages');
      await sendEvent("progress", {
        stage: "generating_pages",
        message: "Ïä¨ÎùºÏù¥Îìú ÏÉùÏÑ± Ï§ë..."
      });

      // Generate all GPT-5.1 insight calls in parallel for maximum speed
      const insightPrompts = topics.map((topic: any, index: number) => ({
        topic,
        index,
        prompt: type === "exam"
          ? `ÎãπÏã†ÏùÄ Ïù¥ Ï£ºÏ†úÎ•º Ï≤òÏùå Î∞∞Ïö∞Îäî ÌïôÏÉùÏóêÍ≤å ÏÑ§Î™ÖÌïòÎäî ÏÑ∏Í≥Ñ ÏµúÍ≥† ÏàòÏ§ÄÏùò ÍµêÏàòÏûÖÎãàÎã§.

**ÌÜ†ÌîΩ**: ${topic.title}
**ÌïµÏã¨ Ìè¨Ïù∏Ìä∏**: ${topic.keyPoints.join(', ')}
**ÎÇúÏù¥ÎèÑ**: ${topic.difficulty === 3 ? 'Ïñ¥Î†§ÏõÄ (Ï∂îÏÉÅÏ†Å/Î≥µÏû°)' : topic.difficulty === 2 ? 'Î≥¥ÌÜµ' : 'Í∏∞Î≥∏'}

Îã§Ïùå 3Í∞ÄÏßÄ Ï§ë **ÏãúÌóòÏóêÏÑú Í∞ÄÏû• Ï§ëÏöîÌïú Í≤É 1Í∞ÄÏßÄÎßå** Í≥®ÎùºÏÑú ÏÑ§Î™ÖÌïòÏÑ∏Ïöî:

1. **Ìó∑Í∞àÎ¶¨Í∏∞ Ïâ¨Ïö¥ Ìè¨Ïù∏Ìä∏**: ÌïôÏÉùÎì§Ïù¥ ÏûêÏ£º Ï∞©Í∞ÅÌïòÍ±∞ÎÇò ÌòºÎèôÌïòÎäî Î∂ÄÎ∂Ñ
2. **ÏïîÍ∏∞ ÌåÅ**: ÏãúÌóò Îïå Îπ†Î•¥Í≤å Îñ†Ïò¨Î¶¥ Ïàò ÏûàÎäî Ïó∞ÏÉÅÎ≤ïÏù¥ÎÇò Ìå®ÌÑ¥
3. **Ïã§Ï†ú Ï†ÅÏö©**: Ïù¥ Í∞úÎÖêÏù¥ Ïã§Ï†ú Î¨∏Ï†úÏóêÏÑú Ïñ¥ÎñªÍ≤å ÎÇòÏò§ÎäîÏßÄ

**Ï∂úÎ†• ÌòïÏãù** (2-3Î¨∏Ïû•, 50-70Îã®Ïñ¥):
"[ÏÑ†ÌÉùÌïú Ìè¨Ïù∏Ìä∏]. [Íµ¨Ï≤¥Ï†Å ÏÑ§Î™Ö]. [Ïôú Ïù¥Í≤å Ï§ëÏöîÌïúÏßÄ]."

**Ï§ëÏöî**: ÏàòÏãùÏù¥ÎÇò Î≥ÄÏàòÎäî LaTeX ÌòïÏãù ÏÇ¨Ïö© (Ïòà: $\\beta=1$, $$E(R) = R_f + \\beta(R_m - R_f)$$)

**ÏòàÏãú**:
"Ìó∑Í∞àÎ¶¨Í∏∞ Ïâ¨Ïö¥ Ìè¨Ïù∏Ìä∏: CAPMÏóêÏÑú $\\beta=1$Ïù¥Î©¥ 'ÏãúÏû•Í≥º Í∞ôÏùÄ Î¶¨Ïä§ÌÅ¨'Ïù¥ÏßÄ, 'Î¶¨Ïä§ÌÅ¨Í∞Ä ÏóÜÎã§'Îäî ÎúªÏù¥ ÏïÑÎãôÎãàÎã§. $\\beta=0$Ïùº ÎïåÎßå Î¨¥ÏúÑÌóòÏûÖÎãàÎã§. ÏãúÌóòÏóêÏÑú Ïù¥ Ï∞®Ïù¥Î•º Î¨ªÎäî Î¨∏Ï†úÍ∞Ä ÏûêÏ£º ÎÇòÏòµÎãàÎã§."`
          : `ÎãπÏã†ÏùÄ 10ÎÖÑÏ∞® ÏãúÎãàÏñ¥Î°úÏÑú ÌõÑÎ∞∞ÏóêÍ≤å Ïã§Î¨¥ ÌåÅÏùÑ ÏïåÎ†§Ï£ºÍ≥† ÏûàÏäµÎãàÎã§.

**ÌÜ†ÌîΩ**: ${topic.title}
**ÌïµÏã¨ Ìè¨Ïù∏Ìä∏**: ${topic.keyPoints.join(', ')}
**ÎÇúÏù¥ÎèÑ**: ${topic.difficulty === 3 ? 'Í≥†Í∏â' : topic.difficulty === 2 ? 'Ï§ëÍ∏â' : 'Í∏∞Î≥∏'}

Îã§Ïùå 3Í∞ÄÏßÄ Ï§ë **Ïã§Î¨¥ÏóêÏÑú Í∞ÄÏû• Ï§ëÏöîÌïú Í≤É 1Í∞ÄÏßÄÎßå** Í≥®ÎùºÏÑú ÏÑ§Î™ÖÌïòÏÑ∏Ïöî:

1. **Ìï®Ï†ï/Î¶¨Ïä§ÌÅ¨**: Ïù¥Í≤É Î™®Î•¥Í≥† ÌñàÎã§Í∞Ä ÌÅ∞ Î¨∏Ï†ú ÏÉùÍ∏¥ Ïã§Ï†ú ÏºÄÏù¥Ïä§
2. **Best Practice**: ÏãúÎãàÏñ¥Îì§Ïù¥ Ïã§Ï†úÎ°ú Ïì∞Îäî ÎÖ∏ÌïòÏö∞
3. **ÎπÑÏ¶àÎãàÏä§ ÏûÑÌå©Ìä∏**: Ïù¥Í≤å ÌöåÏÇ¨ Îß§Ï∂ú/ÎπÑÏö©Ïóê Ïã§Ï†úÎ°ú Ïñ¥Îñ§ ÏòÅÌñ•ÏùÑ Ï£ºÎäîÏßÄ

**Ï∂úÎ†• ÌòïÏãù** (2-3Î¨∏Ïû•, 50-70Îã®Ïñ¥):
"[ÏÑ†ÌÉùÌïú Ìè¨Ïù∏Ìä∏]. [Íµ¨Ï≤¥Ï†Å ÏÑ§Î™Ö]. [Ïôú Ïù¥Í≤å Ï§ëÏöîÌïúÏßÄ]."

**ÏòàÏãú**:
"Ìï®Ï†ï/Î¶¨Ïä§ÌÅ¨: Í≥†Í∞ù ÏÑ∏Í∑∏Î®ºÌä∏ Î∂ÑÏÑùÌï† Îïå 'ÌèâÍ∑†Í∞í'Îßå Î≥¥Î©¥ Ïïà Îê©ÎãàÎã§. Ïã§Ï†úÎ°úÎäî ÏÉÅÏúÑ 10% Í≥†Í∞ùÏù¥ Îß§Ï∂úÏùò 60%Î•º ÎßåÎì§Ïñ¥ÎÇ¥Îäî Í≤ΩÏö∞Í∞Ä ÎßéÏäµÎãàÎã§. ÌèâÍ∑† Í∏∞Ï§ÄÏúºÎ°ú ÎßàÏºÄÌåÖ ÏòàÏÇ∞ Î∞∞Î∂ÑÌïòÎ©¥ ROIÍ∞Ä Ï†àÎ∞òÏúºÎ°ú Îñ®Ïñ¥ÏßëÎãàÎã§."`
      }));

      // Call GPT-5.1 for all insights in parallel
      console.log(`[INSIGHTS] Calling GPT-5.1 for ${insightPrompts.length} slides in parallel...`);
      const insightsStart = Date.now();

      const insightCalls = insightPrompts.map(async ({ topic, index, prompt }) => {
        const callStart = Date.now();
        const response = await openai.chat.completions.create({
          model: INSIGHT_MODEL,
          messages: [
            {
              role: "system",
              content: "You are a senior expert providing deep insights. Be concise and insightful."
            },
            { role: "user", content: prompt }
          ],
          temperature: 1.0,
        });

        // Track API call
        if (response.usage) {
          trackAPICall(
            INSIGHT_MODEL,
            `Deep Insight Generation - Slide ${index + 1}`,
            response.usage,
            callStart
          );
        }

        return {
          index,
          insight: response.choices[0].message.content!.trim()
        };
      });

      const insightResults = await Promise.all(insightCalls);
      console.log(`[INSIGHTS] All ${insightResults.length} insights generated in ${Date.now() - insightsStart}ms`);

      // Now generate slides with insights (fast, no API calls)
      const slides = topics.map((topic: any, index: number) => {
        const insight = insightResults.find(r => r.index === index)?.insight || "";
        return generateSlideWithTemplateSync(topic, index, type, structuredPDF, fullText, insight);
      });

      console.log(`[SLIDES] Generated ${slides.length} slides`);
      endStage('generating_pages');

      // ====================
      // STEP 5.5: Generate final review slides (summary + strategy)
      // ====================
      startStage('generating_review');
      await sendEvent("progress", {
        stage: "generating_review",
        message: "ÏµúÏ¢Ö Ï†ïÎ¶¨ Ïä¨ÎùºÏù¥Îìú ÏÉùÏÑ± Ï§ë..."
      });

      const reviewPrompt = type === "exam"
        ? `ÏãúÌóò ÎåÄÎπÑ ÌïôÏäµ Í∞ÄÏù¥ÎìúÎ•º Í∞ÑÍ≤∞ÌïòÍ≤å ÏûëÏÑ±ÌïòÏÑ∏Ïöî.

ÌïôÏäµ Ïä¨ÎùºÏù¥Îìú Ï†úÎ™© (${slides.length}Í∞ú):
${slides.map((s, i) => `${i + 1}. ${s.title}`).join('\n')}

**ÎßàÏßÄÎßâ 2ÌéòÏù¥ÏßÄ ÏÉùÏÑ±**:

1. "ÌïµÏã¨ Í∞úÎÖê Ï¥ùÏ†ïÎ¶¨" - Ï†ÑÏ≤¥ ÎÇ¥Ïö©ÏùÑ 5-7Í∞ú ÌïµÏã¨ Í∞úÎÖêÏúºÎ°ú ÏïïÏ∂ï Ï†ïÎ¶¨ (Í∞Å 2-3Î¨∏Ïû•, Ï¥ù 150Îã®Ïñ¥ Ïù¥ÎÇ¥)
2. "ÏãúÌóò Ï†ÑÎûµ Í∞ÄÏù¥Îìú" - ÏïîÍ∏∞ ÌïÑÏàò Ìï≠Î™© Ï≤¥ÌÅ¨Î¶¨Ïä§Ìä∏ (5-7Í∞ú, Ï¥ù 100Îã®Ïñ¥ Ïù¥ÎÇ¥)

**Ï§ëÏöî**: Í∞ÑÍ≤∞ÌïòÍ≤å! ÌïµÏã¨Îßå!

JSON:
{
  "reviewPages": [
    {"title": "ÌïµÏã¨ Í∞úÎÖê Ï¥ùÏ†ïÎ¶¨", "content": "...", "keyPoints": ["ÌïµÏã¨1", "ÌïµÏã¨2", "ÌïµÏã¨3"]},
    {"title": "ÏãúÌóò Ï†ÑÎûµ Í∞ÄÏù¥Îìú", "content": "...", "keyPoints": ["Ï†ÑÎûµ1", "Ï†ÑÎûµ2", "Ï†ÑÎûµ3"]}
  ]
}`
        : `Ïã§Î¨¥ Í∞ÄÏù¥ÎìúÎ•º Í∞ÑÍ≤∞ÌïòÍ≤å ÏûëÏÑ±ÌïòÏÑ∏Ïöî.

Ïä¨ÎùºÏù¥Îìú Ï†úÎ™© (${slides.length}Í∞ú):
${slides.map((s, i) => `${i + 1}. ${s.title}`).join('\n')}

**ÎßàÏßÄÎßâ 2ÌéòÏù¥ÏßÄ ÏÉùÏÑ±**:

1. "ÌïµÏã¨ ÌîÑÎ°úÏÑ∏Ïä§ Ï¥ùÏ†ïÎ¶¨" - ÏóÖÎ¨¥ ÌùêÎ¶ÑÏùÑ 5-7Í∞ú ÌïµÏã¨ ÌîÑÎ°úÏÑ∏Ïä§Î°ú ÏïïÏ∂ï (Í∞Å 2-3Î¨∏Ïû•, Ï¥ù 150Îã®Ïñ¥ Ïù¥ÎÇ¥)
2. "Ïã§Î¨¥ Ï†ÅÏö© ÏöîÏïΩ" - Î∞îÎ°ú Ï†ÅÏö© Í∞ÄÎä•Ìïú Ï≤¥ÌÅ¨Î¶¨Ïä§Ìä∏ (5-7Í∞ú, Ï¥ù 100Îã®Ïñ¥ Ïù¥ÎÇ¥)

**Ï§ëÏöî**: Í∞ÑÍ≤∞ÌïòÍ≤å! ÌïµÏã¨Îßå!

JSON:
{
  "reviewPages": [
    {"title": "ÌïµÏã¨ ÌîÑÎ°úÏÑ∏Ïä§ Ï¥ùÏ†ïÎ¶¨", "content": "...", "keyPoints": ["ÌîÑÎ°úÏÑ∏Ïä§1", "ÌîÑÎ°úÏÑ∏Ïä§2", "ÌîÑÎ°úÏÑ∏Ïä§3"]},
    {"title": "Ïã§Î¨¥ Ï†ÅÏö© ÏöîÏïΩ", "content": "...", "keyPoints": ["Ï†ÅÏö©1", "Ï†ÅÏö©2", "Ï†ÅÏö©3"]}
  ]
}`;

      const reviewCallStart = Date.now();
      const reviewResponse = await openai.chat.completions.create({
        model: STRUCTURE_MODEL, // Use Mini for review pages (cheaper)
        messages: [
          { role: "system", content: "You are a study guide expert. Generate comprehensive review pages in Korean." },
          { role: "user", content: reviewPrompt }
        ],
        response_format: { type: "json_object" },
        temperature: 1.0
      });

      // Track Mini API call for review
      if (reviewResponse.usage) {
        trackAPICall(
          STRUCTURE_MODEL,
          "Review Slides Generation (Mini)",
          reviewResponse.usage,
          reviewCallStart
        );
      }

      const reviewData = JSON.parse(reviewResponse.choices[0].message.content || "{}");
      const reviewPages = reviewData.reviewPages || [];
      console.log(`[REVIEW] Generated ${reviewPages.length} review pages`);
      endStage('generating_review');

      // ====================
      // STEP 6: Save slides to database (as JSON in analysis column)
      // ====================
      startStage('save_slides');
      const allPages = slides.map((slide, index) => ({
        page: index + 1,
        title: slide.title,
        content: slide.content,
        keyPoints: topics[index]?.keyPoints || []
      }));

      // Add review pages
      reviewPages.forEach((page: any, idx: number) => {
        allPages.push({
          page: slides.length + idx + 1,
          title: page.title,
          content: page.content,
          keyPoints: page.keyPoints || []
        });
      });

      // Calculate final metrics
      metrics.totalDuration = Date.now() - metrics.startTime;

      // Prepare metrics summary
      const metricsSummary = {
        totalDuration: metrics.totalDuration,
        totalTokens: metrics.totalTokens,
        totalCost: metrics.totalCost,
        stages: Object.entries(metrics.stages).map(([name, data]) => ({
          name,
          duration: data.duration || 0,
        })),
        apiCalls: metrics.apiCalls.map(call => ({
          model: call.model,
          purpose: call.purpose,
          tokens: call.totalTokens,
          cost: call.cost,
          duration: call.duration,
        })),
        costBreakdown: {
          miniCost: metrics.apiCalls
            .filter(c => c.model.includes('mini'))
            .reduce((sum, c) => sum + c.cost, 0),
          gpt51Cost: metrics.apiCalls
            .filter(c => c.model.includes('5.1'))
            .reduce((sum, c) => sum + c.cost, 0),
        },
        performance: {
          slidesGenerated: allPages.length,
          avgTimePerSlide: Math.round(metrics.stages.generating_pages?.duration || 0 / allPages.length),
          tokenReduction: Math.round((1 - lightweightSummary.length / fullText.length) * 100),
        }
      };

      console.log(`[METRICS] ===== Analysis Complete =====`);
      console.log(`[METRICS] Total Duration: ${(metrics.totalDuration / 1000).toFixed(2)}s`);
      console.log(`[METRICS] Total Tokens: ${metrics.totalTokens.toLocaleString()}`);
      console.log(`[METRICS] Total Cost: $${metrics.totalCost.toFixed(4)}`);
      console.log(`[METRICS] Cost Breakdown: Mini=$${metricsSummary.costBreakdown.miniCost.toFixed(4)}, GPT-5.1=$${metricsSummary.costBreakdown.gpt51Cost.toFixed(4)}`);

      const { error: updateError } = await supabase
        .from("materials")
        .update({
          analysis: {
            page_analyses: allPages,
            metrics: metricsSummary,
            status: 'completed',
            generatedAt: new Date().toISOString(),
          }
        })
        .eq("id", material.id);

      if (updateError) {
        console.error("[MATERIAL] Error updating material with slides:", updateError);
        throw new Error(`Failed to save slides: ${updateError.message}`);
      }

      console.log(`[MATERIAL] Successfully saved ${allPages.length} slides with metrics`);
      endStage('save_slides');

      // Send page events to frontend
      for (let i = 0; i < allPages.length; i++) {
        await sendEvent("page", {
          index: i,
          total: allPages.length,
          title: allPages[i].title
        });
      }

      // Send metrics to frontend
      await sendEvent("metrics", metricsSummary);

      await sendEvent("complete", { materialId: material.id });
      await writer.close();

    } catch (error: any) {
      console.error("Analysis error:", error);
      await sendEvent("error", { error: error.message });
      await writer.close();
    }
  })();

  return new Response(stream.readable, {
    headers: {
      "Content-Type": "text/event-stream",
      "Cache-Control": "no-cache",
      "Connection": "keep-alive",
    },
  });
}

/**
 * Generate slide with template + pre-fetched GPT insight
 *
 * Template handles:
 * - Title
 * - Structure (sections, formulas, examples from parsed data)
 * - Formatting
 *
 * GPT-5.1 insight is pre-fetched (for parallel processing)
 */
function generateSlideWithTemplateSync(
  topic: any,
  index: number,
  type: "exam" | "work",
  structuredPDF: any,
  fullText: string,
  insight: string
): { title: string; content: string } {

  const title = topic.title;

  // Find relevant sections from structured PDF
  const relevantSections = structuredPDF.sections
    .filter((s: any) =>
      s.content.toLowerCase().includes(title.toLowerCase().split(' ')[0]) ||
      s.type === 'formula' ||
      s.type === 'example'
    )
    .slice(0, 5);

  // Build template-based content
  let templateContent = `## ${title}\n\n`;

  // Core concept section - Format as structured paragraphs
  templateContent += `#### üìå ÌïµÏã¨ Í∞úÎÖê\n\n`;

  // Strategy: Use coreContent if substantial, otherwise enrich from keyPoints and sections
  const hasCoreContent = topic.coreContent && topic.coreContent.length > 50;

  if (hasCoreContent) {
    // Format coreContent with proper structure
    let formattedCore = topic.coreContent;

    // First, make structural markers bold (handle both at start and after punctuation)
    formattedCore = formattedCore
      .replace(/^(Ï†ïÏùò:)/g, '**$1**')
      .replace(/^(ÌäπÏßï:)/g, '**$1**')
      .replace(/^(Î∞©Î≤ï:)/g, '**$1**')
      .replace(/^(Ï§ëÏöîÏÑ±:)/g, '**$1**')
      .replace(/^(ÏàòÏãù:)/g, '**$1**')
      .replace(/^(ÏòàÏãú:)/g, '**$1**')
      .replace(/([.!?])\s*(Ï†ïÏùò:)/g, '$1\n\n**$2**')
      .replace(/([.!?])\s*(ÌäπÏßï:)/g, '$1\n\n**$2**')
      .replace(/([.!?])\s*(Î∞©Î≤ï:)/g, '$1\n\n**$2**')
      .replace(/([.!?])\s*(Ï§ëÏöîÏÑ±:)/g, '$1\n\n**$2**')
      .replace(/([.!?])\s*(ÏàòÏãù:)/g, '$1\n\n**$2**')
      .replace(/([.!?])\s*(ÏòàÏãú:)/g, '$1\n\n**$2**');

    // If no structural markers found, try to detect and format naturally
    if (!formattedCore.includes('**Ï†ïÏùò:**') && formattedCore.match(/^[^.!?]{10,}?Îäî\s+[^.!?]+(?:ÏûÖÎãàÎã§|Ïù¥Îã§|Îê©ÎãàÎã§)/)) {
      formattedCore = formattedCore.replace(/^([^.!?]+?(?:ÏûÖÎãàÎã§|Ïù¥Îã§|Îê©ÎãàÎã§)[.!?])/, '**Ï†ïÏùò:**\n$1');
    }

    templateContent += `${formattedCore}\n\n`;
  } else {
    // Build richer content from keyPoints
    if (topic.keyPoints && topic.keyPoints.length >= 2) {
      // Use first 2-3 keyPoints as core explanation
      const corePoints = topic.keyPoints.slice(0, 3);
      templateContent += corePoints.map((point: string, idx: number) =>
        idx === 0 ? point : `ÎòêÌïú, ${point.toLowerCase()}`
      ).join(' ') + '\n\n';
    } else {
      // Last resort: find relevant paragraph from sections
      const conceptSection = relevantSections.find((s: any) => s.type === 'paragraph');
      if (conceptSection) {
        const sentences = conceptSection.content.split(/[.!?]/).filter((s: string) => s.trim().length > 10);
        const firstSentences = sentences.slice(0, 3).join('. ') + '.';
        templateContent += `${firstSentences}\n\n`;
      } else {
        templateContent += `${topic.keyPoints.join('. ')}.\n\n`;
      }
    }
  }

  // Formula section removed - formulas should be included in coreContent by Mini model
  // Mini model is instructed to include formulas in LaTeX format within coreContent

  // Example section (only if needed for difficult concepts)
  if (topic.needsExample && topic.difficulty >= 2) {
    const exampleSection = relevantSections.find((s: any) => s.type === 'example');
    if (exampleSection) {
      templateContent += `#### üìù ÏòàÏãúÎ°ú Ïù¥Ìï¥ÌïòÍ∏∞\n\n${exampleSection.content.slice(0, 300)}\n\n`;
    }
  }

  // Add insight section with all keyPoints
  templateContent += `#### üí° Ïù¥Ìï¥ÌïòÍ∏∞\n\n`;

  // Show all keyPoints as bullet list for better comprehension
  if (topic.keyPoints && topic.keyPoints.length > 0) {
    topic.keyPoints.forEach((point: string) => {
      templateContent += `- ${point}\n`;
    });
    templateContent += `\n`;
  }

  templateContent += `> üí° **Ìïú Í±∏Ïùå Îçî**: ${insight}\n\n`;

  return {
    title,
    content: templateContent
  };
}
